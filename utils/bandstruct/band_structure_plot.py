import re
import numpy as np
import matplotlib.pyplot as plt

Ha2eV = 27.211386245988 # 1 Ha = 27.211386245988 eV

def read_eigen_file(fname, unit="Ha"):
    """Read eigenvlaues and occupations from the given .eigen file
    generated by SPARC.

    Parameters
    ----------
    fname : string
        File name (can be a path, relative or absolute) of the
        eigenvalue file generated by SPARC.
    unit : string, optional
        Unit of the returned eigenvalues.

    Returns
    -------
    eigdata : dict
        Eigenvalue information dictionary.

        * eigdata['spin_polarization'] is
          - True if the test system is spin-polarized,
          - False if the test system is spin-unpolarized.
        * eigdata['eigunit'] is the unit of the eigenvalues stored.
        * eigdata['nkpt'] is the number of k-points.
        * eigdata['data'] is a list of information dictionaries with keys:
            "kred"    : k-point coordinates (reduced).
            "weight"  : weight of the k-point.
            "eigvals" : eigenvalues of the k-point,
                        size=(1,nkpt) w/o spin, or (2,nkpt) w/ spin.
            "occs"    : occupations of the bands corresponding to the k-point,
                        size=(1,nkpt) w/o spin, or (2,nkpt) w/ spin.
    """

    with open(fname, 'r') as f:
        content = f.read()
        f.seek(0)
        lines = f.readlines()

    match = re.search(r"Spin-down", content)
    if match:
        spin_polarization = True
    else:
        spin_polarization = False

    eigdata = {
            "eig_unit": unit,
            "spin_polarization": spin_polarization,
            "nkpt" : 0,
            "data" : []}

    if (eigdata["eig_unit"].lower() == "ha"):
        unit_trans = 1.0
    elif (unit.lower() == "ev"):
        unit_trans = Ha2eV

    for line in lines:
        if line.startswith("kred"):
            kred_value = list(map(float, line.split("=")[1].strip().strip("()").split(",")))
            eigdata["data"].append({
                "kred": kred_value,
                "weight": 1.0,
                "eigvals": ([[],[]] if spin_polarization else [[]]),
                "occs": ([[],[]] if spin_polarization else [[]])
            })
            eigdata["nkpt"] += 1
        elif line.startswith("weight"):
            eigdata["data"][-1]["weight"] = float(line.split("=")[1].strip())
        elif line.strip():
            try:
                parts = line.split()
                #n = int(parts[0])
                eigdata["data"][-1]["eigvals"][0].append(float(parts[1])*unit_trans)
                eigdata["data"][-1]["occs"][0].append(float(parts[2]))
                if spin_polarization:
                    eigdata["data"][-1]["eigvals"][1].append(float(parts[3])*unit_trans)
                    eigdata["data"][-1]["occs"][1].append(float(parts[4]))
            except:
                pass  # Skip lines that don't match the expected format
    #print(json.dumps(eigdata,separators=(',',':'),skipkeys = True,indent = 6))
    return eigdata


def process_band_data(eigdata):
    """Process band data created by read_eigen_file(). Calculate k-point
    distances in the band structure plot.

    Parameters
    ----------
    eigdata : dict
        Eigenvalue information dictionary.

        * eigdata['spin_polarization'] is
          - True if the test system is spin-polarized,
          - False if the test system is spin-unpolarized.
        * eigdata['eigunit'] is the unit of the eigenvalues stored.
        * eigdata['nkpt'] is the number of k-points.
        * eigdata['data'] is a list of information dictionaries with keys:
            "kred"    : k-point coordinates (reduced).
            "weight"  : weight of the k-point.
            "eigvals" : eigenvalues of the k-point,
                        size=(1,nkpt) w/o spin, or (2,nkpt) w/ spin.
            "occs"    : occupations of the bands corresponding to the k-point,
                        size=(1,nkpt) w/o spin, or (2,nkpt) w/ spin.

    Returns
    -------
    kpt_dist : list
        Distances of the k-points on the k-point path.
    eigvals : numpy array
        Eigenvalues of all the k-points. When spin is present, eigvals[0]
        contains the eigenvalues for spin-up values and eigvals[1] for spin-
        down.
    kpt_coords : k-point coordinates.
    """

    spin_polarization = eigdata["spin_polarization"]
    data = eigdata["data"]

    kpt_coords = []
    kpt_dist = []
    eigvals = [[],[]] if spin_polarization else [[]]
    ref = data[0]["kred"]
    pos = 0.0
    for i in data:
        kpt_coords.append(i["kred"])
        dis = ((ref[0]-i["kred"][0])**2 + (ref[1]-i["kred"][1])**2 + (ref[2]-i["kred"][2])**2)**0.5
        ref = i["kred"]
        pos += dis
        kpt_dist.append(pos)
        for spin in range(len(eigvals)):
            eigvals[spin].append(i["eigvals"][spin])

    for spin in range(len(eigvals)):
        eigvals[spin] = np.array(eigvals[spin]).T

    return kpt_dist, np.array(eigvals), kpt_coords


def change_extension(input_filename, new_extension):
    """Change the extension of input_filename to a given
    extension.
    """
    # Split the input filename by '.'
    parts = input_filename.split('.')

    # Check if there's an extension to replace
    if len(parts) > 1:
        # Replace the last part (extension) with new_extension
        parts[-1] = new_extension
        # Join the parts back together to create the new filename
        output_filename = '.'.join(parts)
    else:
        # If there was no extension, just append new_extension to the filename
        output_filename = input_filename + '.' + new_extension

    return output_filename


class InvalidInputError(Exception):
    pass


def create_band_structure_plot(
        kpt_dist, eigvals, nkpt_per_line, outfname, highsym_points='', unit='eV',
        Efermi_Ha = None, Efermi_eV = None, ylim = None, dpi = 300., plotstyles={}):
    """Plot band structure using the data processed by `process_band_data()`.

    Parameters
    ----------
    kpt_dist : list
        Distances of the k-points on the k-point path.
    eigvals : numpy array
        Eigenvalues of all the k-points.
    nkpt_per_line : int
        Number of k-points on each line segment (between two high symmetry
        points).
    highsym_points : string
        Symbols of the high-symmetry points, used for xticks.
        Example: 'G-X-W-K', 'G-X-W|G-K'
    unit : string
        unit of the energy in the final plot.
    Efermi_Ha : float
        Fermi level in Hartree. Cannot be specified together with Efermi_eV.
    Efermi_eV : float
        Fermi level in eV. Cannot be specified together with Efermi_Ha.
    outfname : string
        Output band structure plot file name. Default is set to fname with
        extension changed to "png".
    ylim : tuple -> (float, float)
        Y limits of the final plot.
    dpi : float
        Dots Per Inch (dpi) of the resulting plot.
    plotstyles : dict
        Plot style controls, currently supports:
            "linewidth"  : (float) line width of the bands.
            "vlinewidth" : (float) line width of the vertical lines.
            "spin_style" : (list of strings) line styles that discreminates the spin-up
                           and spin-down bands.
            "xlabel"     : (string) x label.
            "ylabel"     : (string) y label.
    """

    # define plot styles
    linewidth = 1.0 if 'linewidth' not in plotstyles else plotstyles['linewidth']
    vlinewidth = 0.75 if 'vlinewidth' not in plotstyles else plotstyles['vlinewidth']
    if 'spin_style' in plotstyles:
        if isinstance(plotstyles['spin_style'], str):
            spin_style = [plotstyles['spin_style'], plotstyles['spin_style']]
        elif isinstance(plotstyles['spin_style'], list):
            if len(plotstyles['spin_style'])==1:
                spin_style = [plotstyles['spin_style'][0], plotstyles['spin_style'][0]]
            else:
                spin_style = [plotstyles['spin_style'][0], plotstyles['spin_style'][1]]
    else:
        spin_style = ['k-', 'r--']

    xlabel = 'Wave vector' if 'xlabel' not in plotstyles else plotstyles['xlabel']
    ylabel = 'Energy'
    if 'ylabel' in plotstyles:
        ylabel = plotstyles['ylabel']
    else:
        if unit.lower() == 'ha':
            ylabel = "Energy (Ha)"
        elif unit.lower() == 'ev':
            ylabel = "Energy (eV)"

    # check if Efermi is provided properly
    if (Efermi_eV != None and Efermi_Ha != None):
        raise InvalidInputError("`Efermi_eV` and `Efermi_Ha` cannot be set simultaneously")
    elif (Efermi_eV != None):
        Efermi = Efermi_eV
        if unit.lower() == 'ha':
            Efermi /= Ha2eV
    elif (Efermi_Ha != None):
        Efermi = Efermi_Ha
        if unit.lower() == 'ev':
            Efermi *= Ha2eV
    else:
        Efermi = None

    _, ax = plt.subplots()

    if (Efermi != None):
        ax.axhline(y = Efermi, color = 'g', linestyle = '--')

    spin_polarization = len(eigvals) > 1
    
    if len(highsym_points) == 0:
        for spin in range(len(eigvals)):
            for y in range(len(eigvals[spin])):
                label = None
                if spin_polarization and y == 0:
                    label = 'spin-up' if (spin == 0) else 'spin-down'
                ax.plot(kpt_dist, eigvals[spin, y, :], spin_style[spin], linewidth=linewidth, label = label)
    else:
        highsym_points = highsym_points.split()
        #Connect different lines
        len_flag = 0
        for e in highsym_points[:len(highsym_points)-1]:
            edge_len = len(e.split('-'))-1
            len_flag += edge_len*nkpt_per_line
            diff = kpt_dist[len_flag]-kpt_dist[len_flag-1]
            for i in range(len_flag,len(kpt_dist)):
                kpt_dist[i] = kpt_dist[i] - diff

        for spin in range(len(eigvals)):
            for y in range(len(eigvals[spin])):
                label = None
                if spin_polarization and y == 0:
                    label = 'spin-up' if (spin == 0) else 'spin-down'

                ax.plot(kpt_dist, eigvals[spin, y, :], spin_style[spin], linewidth=linewidth, label = label)

        # Make high symmteric vertical lines
        tick_x = []
        for i in range(0,len(kpt_dist)-1,nkpt_per_line):
            tick_x.append(kpt_dist[i])
            plt.axvline(kpt_dist[i], linewidth=vlinewidth, linestyle ="--", color='k', alpha=0.5)

        tick_x.append(kpt_dist[-1])
        plt.axvline(kpt_dist[-1], linewidth=vlinewidth, linestyle ="--", color='k', alpha=0.5)

        # Make x tick
        tick_kpt = '|'.join(highsym_points)
        tick_kpt = tick_kpt.split('-')
        tick_kpt = [item.replace('G', r"$\Gamma$") for item in tick_kpt]
        # tick_kpt = [item.replace('|', r"$|$") for item in tick_kpt]
        plt.xticks(ticks=tick_x, labels=tick_kpt)

    plt.xlim(min(kpt_dist), max(kpt_dist))

    if ylim != None:
        plt.ylim(ylim)

    plt.xlabel(xlabel=xlabel)
    plt.ylabel(ylabel=ylabel)

    # Customize the tick parameters
    ax.tick_params(axis='both', direction='in', which='both')

    if spin_polarization:
        plt.legend(loc="upper right")

    plt.savefig(outfname, format="png", dpi=dpi)


def plot_band_structure(
        fname, nkpt_per_line, highsym_points='', unit='eV',
        Efermi_Ha = None, Efermi_eV = None, outfname=None,
        ylim = None, dpi = 300., plotstyles={}):
    """Plot band structure using the data from the given file.

    Parameters
    ----------
    fname : string
        File name of the .eigen file generated by SPARC.
    nkpt_per_line : int
        Number of k-points on each line segment (between two high symmetry
        points).
    highsym_points : string, optional
        Symbols of the high-symmetry points, used for xticks.
        Example: 'G-X-W-K', 'G-X-W|G-K'
    unit : string, optional
        unit of the energy in the final plot.
    Efermi_Ha : float, optional
        Fermi level in Hartree. Cannot be specified together with Efermi_eV.
    Efermi_eV : float, optional
        Fermi level in eV. Cannot be specified together with Efermi_Ha.
    outfname : string, optional
        Output band structure plot file name. Default is set to fname with
        extension changed to "png".
    ylim : tuple -> (float, float), optional
        Y limits of the final plot.
    dpi : float, optional
        Dots Per Inch (dpi) of the resulting plot.
    plotstyles : dict
        Plot style controls, currently supports:
            "linewidth"  : (float) line width of the bands.
            "vlinewidth" : (float) line width of the vertical lines.
            "spin_style" : (list of strings) line styles that discreminates the spin-up
                           and spin-down bands.
            "xlabel"     : (string) x label.
            "ylabel"     : (string) y label.
    """
    # read data from .eigen file
    data = read_eigen_file(fname, unit=unit)

    # process the data, find k-point distances
    kpt_dist, eigvals, _ = process_band_data(data)

    if outfname == None:
        outfname = change_extension(fname, new_extension="png")

    # create band structure plot and save to file
    create_band_structure_plot(kpt_dist, eigvals, nkpt_per_line,
                               outfname, highsym_points, unit,
                               Efermi_Ha, Efermi_eV, ylim, dpi,
                               plotstyles)



if __name__ == '__main__':
    
    fname = 'example/CdS.eigen_01'
    highsym_points = 'G-X-W-K-G-L-U-W-L-K'

    Efermi = 0.42712 # in Ha
    nkpt_per_line = 10

    # plot_band_structure(fname, nkpt_per_line, highsym_points, Efermi_Ha=Efermi)
    # plot_band_structure(fname, nkpt_per_line, highsym_points, plotstyles = {"xlabel": None})
    plot_band_structure(fname, nkpt_per_line, highsym_points,
                       unit='eV', Efermi_Ha=Efermi, ylim=(-10,30), dpi=200)

